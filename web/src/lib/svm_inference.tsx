// @ts-ignore
import * as svm from 'libsvm-js/asm'



enum Feature{
  max,
  min
};



export function svm_predict_with_model (
  /* the input array of numbers (length of N) for inference */
  array_to_predict: number[],

  /* serialized model in string format, which is generated by svm-train libsvm */
  /* Check svm_covid_19_model_parameters.ts for example */
  serialized_model: string,

  feature_min_max: string
): -1 | 1 {
  const return_vector = new Array(15) as number[]
  // preprocess input vector


  console.log(feature_min_max);
  const feature_min_array = parse_feature_scaling_string(feature_min_max, Feature.min);
  const feature_max_array = parse_feature_scaling_string(feature_min_max, Feature.max);


  //show in console
  console.log("Feature max and min: "); console.log(feature_max_array); console.log(feature_min_array);

  const preprocessed_vector = scale_input_array(
    array_to_predict,
    feature_min_array,
    feature_max_array
  )

  console.log('Preprocessed vector is ' + preprocessed_vector)
  // load the model
  const pretrained_model = svm.load(serialized_model)

  // predict the parameters. The predict function takes a 2D array of number.
  // so we input as a *1 vector and get the label with index of 1
  const label = pretrained_model.predict([preprocessed_vector])
  return label[0]
}

/* This function is to preprocess the input array of numbers with max
and min value from training dataset, which is just the same as svm-scale */
function scale_input_array (array_to_predict: number[], feature_min_array: number[]
  , feature_max_array: number[]): number[] {
  if (array_to_predict.length !== feature_max_array.length ||
    array_to_predict.length !== feature_min_array.length) {
    throw new Error('Please check input dimensions.')
  }

  const return_vector: number[] = new Array(array_to_predict.length)

  for (let i = 0; i < array_to_predict.length; i++) {
    return_vector[i] =
      (array_to_predict[i] - feature_min_array[i]) /
      (feature_max_array[i] - feature_min_array[i])
  }

  return return_vector
}



function isEmptyOrSpaces(str:string):boolean{
  return str === null || str.match(/^ *$/) !== null;
}


/* This function is to parse the feature max/min string into array of numbers */
function parse_feature_scaling_string(input_string:string, option:Feature) : number[]{
  let return_array: number[] = [];

  //1. Split input_string into array of string by new line '\n' and/or '\r\n'
  let splitted_result = input_string.split(/\r?\n/);

  console.log(splitted_result);
  //2. split each line by space, then add max or min value of current feature into return_array
  for (let each_line of splitted_result){
    console.log(each_line);
    let splitted_each_line = each_line.split(' ');
    if (splitted_each_line.length != 3 || isEmptyOrSpaces(each_line)) continue;
    if (option == Feature.max) {
      return_array.push(parseFloat(splitted_each_line[2]));
    }
    else{
      return_array.push(parseFloat(splitted_each_line[1]));
    }
  }

  return return_array;

}